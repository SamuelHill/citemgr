import com.github.rjeschke.txtmark.*

buildscript {
  apply from: "versions.gradle"
    repositories {
        mavenCentral()
	maven {
	  url "http://beta.hpcc.uh.edu/nexus/content/groups/public"
	}
    }
    dependencies {
      classpath group: 'com.github.rjeschke', name: 'txtmark', version: '0.11'


      classpath group: 'edu.holycross.shot', name : 'hocuspocus' , version: hocuspocusVersion
      classpath group: 'edu.holycross.shot', name : 'prestochango' , version: prestochangoVersion
      classpath group: 'edu.holycross.shot', name : 'abracadabra' , version: abracadabraVersion
      classpath group: 'edu.holycross.shot', name : 'nysi' , version: nysiVersion
      classpath group:       'org.homermultitext', name : 'hmt-utils', version: hmtutilsVersion
    }
}

import edu.holycross.shot.hocuspocus.Corpus
import edu.holycross.shot.prestochango.CollectionArchive
import edu.holycross.shot.abracadabra.CiteIndex
import edu.holycross.shot.nysi.ImgTurtleizer
import org.homermultitext.utils.HmtTokenizer
      
import org.apache.tools.ant.filters.*

apply plugin: "base"
apply plugin:  "groovy"
apply plugin:  "maven"

apply from: "versions.gradle"




if (! hasProperty('prefix')) {
    apply from: "options.gradle"
}

/* Settings for Digital Scholarly Edition data */
if (hasProperty('dse')) {
    apply from: dse
}


if (hasProperty('schema')) {
    System.err.print "Using schemas defined in ${schema}"
    File confFile = new File(schema)
    if (! confFile.exists()) {
        throw new Exception("No configuration file ${schema} found.")
    }
    apply from: schema

} else {
    File confFile = new File("schemas.gradle")
    if (! confFile.exists()) {
        throw new Exception("No configuration file 'schemas.gradle' found.")
    }
    println "Using default publication configuration in 'schemas.gradle'"
    apply from: "schemas.gradle"
}



if (hasProperty('pub')) {
    System.err.print "Using publication configuration from ${pub}"
    File confFile = new File(pub)
    if (! confFile.exists()) {
        throw new Exception("No configuration file ${pub} found.")
    }
    apply from: pub

} else {
    File confFile = new File("pubconf.gradle")
    if (! confFile.exists()) {
        throw new Exception("No configuration file 'pubconf.gradle' found.")
    }
    println "Using default publication configuration in 'pubconf.gradle'"
    apply from: "pubconf.gradle"
}


// Consider possible configurations:
if (hasProperty('conf')) {
    System.err.print "Using configuration data from ${conf}"
    File confFile = new File(conf)
    if (! confFile.exists()) {
        throw new Exception("No configuration file ${conf} found.")
    }
    apply from: conf

} else {
    File confFile = new File("conf.gradle")
    if (! confFile.exists()) {
        throw new Exception("No configuration file ${conf} found.")
    }
    println "Using default configuration in 'conf.gradle'"
    apply from: "conf.gradle"
}



group = "org.homermultitext"

version = '0.5.18'

repositories {
    mavenCentral()
    
    maven {
        url "http://beta.hpcc.uh.edu/nexus/content/groups/public"
    }
    maven {
      url "https://oss.sonatype.org"
    }
}

configurations {
  rdf
  lib
}

dependencies {
  compile group: 'org.codehaus.groovy', name: 'groovy-all', version: groovyVersion

  compile group: 'edu.holycross.shot', name: 'nysi', version: nysiVersion
  compile group: 'edu.holycross.shot', name : 'hocuspocus' , version: hocuspocusVersion
  compile group : 'edu.holycross.shot', name : 'prestochango', version : prestochangoVersion
  compile group : 'edu.holycross.shot', name : 'abracadabra', version : abracadabraVersion
  
  compile group: 'edu.harvard.chs', name: 'cite', version: citeVersion
  compile group: 'edu.harvard.chs', name : 'greekutils' , version: greekutilsVersion

  compile group: 'net.sf.opencsv', name: 'opencsv', version: '2.3'


  compile group:       'org.homermultitext', name : 'hmt-utils', version: '0.2.8'
  // needed for hocuspocus:
  compile group: 'com.thaiopensource', name:'jing', version: jingVersion
  compile group: 'net.sf.saxon', name: 'saxon-dom', version: saxonVersion


  testCompile 'junit:junit:4.11'
  testCompile 'org.concordion:concordion:1.4.4'
  
  //testCompile group: 'junit', name: 'junit', version: junitVersion
  testCompile group :'xmlunit', name: 'xmlunit', version: xmlunitVersion
}

task squawk {
}
squawk.doLast {
  def ccSettings = ["${collinv}", "file://localhost${projectDir}/${collectionInvUrl}", "${collarchive}", "${buildDir}/ttl", "${prefix}"]
  println "Settings for CC TTL:"
  ccSettings.each {
    println "\t" + it
  }
}


task checkti(type: JavaExec, dependsOn: compileGroovy) {
    description = "Verifies contents of configured text inventory."
    
    main = "org.homermultitext.citemanager.TIVerifier"
    args = ["${ctsinventory}"]

    classpath sourceSets.main.output.classesDir
    classpath configurations.runtime
}

task checkccinv() {
    description = "Verifies contents of configured collection inventory."
    doLast {
        System.err.println "checkccinv:  not yet implemented."
    }
}

task checkidxinv() {
    description = "Verifies contents of configured collection inventory."
    doLast {
        System.err.println "checkidxinv:  not yet implemented."
    }
}

task checkimginv() {
    description = "Verifies contents of configured collection inventory."
    doLast {
        System.err.println "checkimginv:  not yet implemented."
    }
}


task ctstab() {
  description = "Generates a tabular representation of all texts in configured text archive."
}

ctstab.doFirst() {
  if (! buildDir.exists()) {
    buildDir.mkdir()
  }
  File tabs = new File(buildDir, "tabs")
  if (! tabs.exists()) {
    tabs.mkdir()
  }
}
ctstab.doLast() {
  println "build corpus from " + ctsinventory + " and " + ctsarchive
  println "Work in " + buildDir
  Corpus c = new Corpus(new File("${ctsinventory}"), new File("${ctsarchive}", new File("${textInvSchema}")))
  c.debug = 10
  c.tabulateRepository(new File(buildDir, "tabs"))
}


task ctsttl() {
  description = "Generates TTL statements about text contents"
}
ctsttl.doFirst {
  System.err.println "ctsttl will use inventory ${ctsinventory}"
  System.err.println "and archive ${ctsarchive}"


}
ctsttl.doLast {
  if (! buildDir.exists()) {
    buildDir.mkdir()
  }

  File inv
  File archiveDir

  if ((ctsinventory != "") && (ctsarchive != "")) {
    try {
      inv = new File("${ctsinventory}")
      archiveDir = new File("${ctsarchive}")
    } catch (Exception e) {
      System.err.println "ctsttl: unable to create inventory and archive!"
      throw e
    }
    Corpus c = new Corpus(inv,archiveDir, new File(textInvSchema))

    File ttlDir = new File(buildDir, "ttl")
    if (! ttlDir.exists()) {
      ttlDir.mkdir()
    }
    File ttlFile = new File(ttlDir,"cts.ttl")
    c.ttl(ttlFile, prefix, ttlDir)
  }
}


task filterImgs(type: Copy) {
  description = "Filter copies configurable image collection info."
  from (file(imgcolldir)) {
    include '*.csv'
  }
  filter(ReplaceTokens, tokens : [pyramids : pyramids] )
  into "${buildDir}/images"
}
filterImgs.doFirst {
  println "Filter copy images in " + imgcolldir
}


task imgttl(dependsOn: [filterImgs]) {
  description = "Generates RDF for configured NYSI"
}
imgttl.doLast {
  boolean prefix = project.hasProperty("prefix-all")

  File rdfDir = new File("${buildDir}/ttl")
  if (! rdfDir.exists()) {
    rdfDir.mkdir()
  }
  File ttlFile = new File(rdfDir,"citeimgs.ttl")
   
  ImgTurtleizer imgttl = new ImgTurtleizer("${buildDir}/images")

  File imageDir = new File("${buildDir}/images")
  if (! buildDir.exists()) {
    buildDir.mkdir()
  }
  if (! imageDir.exists()) {
    imageDir.mkdir()
  }

  imgttl.ttl(ttlFile, prefix)
}




task ccttl {
  description = "Generates RDF for Collections configured for prestochango"
}
/*
ccttl.doLast {
  String schemaFileName = "schemas/cite/CiteCollectionInventory.rng"
  File csvInv = new File(collinv)

  println "ARCHIVE: " + collarchive

  //String csvDataDir = "/Users/nsmith/Desktop/citevm/repositories/op/collections"
  //File csvDir = new File(csvDataDir)
  File csvDir = new File(collarchive)

  CollectionArchive cc = new CollectionArchive(csvInv, schemaFileName, csvDir)

  cc.debug = 5

  if (! buildDir.exists()) {
    buildDir.mkdir()
  }
  File testOut = new File("${buildDir}/opOut.ttl")
  cc.ttl(testOut)
  System.err.println "TTL in ${testOut}"
}*/

ccttl.doLast {
  boolean prefix = project.hasProperty("prefix-all")

  File schemaFile = new File("schemas/cite/CiteCollectionInventory.rng")

  File invFile = new File(collinv)
  File archiveDir = new File(collarchive)
  CollectionArchive cc = new CollectionArchive(invFile, schemaFile, archiveDir)
  //cc.debug = 5
  println "\nFrom inventory in ${collinv} and data in ${collarchive}:"
  println "\tCollection list:  " + cc.getCollectionList() + "\n"
  if (! buildDir.exists()) {
    buildDir.mkdir()
  }
  File ttlDir = new File(buildDir, "ttl")
  if (! ttlDir.exists()) {
    ttlDir.mkdir()
  }
  File testOut = new File(ttlDir, "collections.ttl")
  cc.ttl(testOut, prefix)
}


task idxttl () {
  description = "Generates RDF for indices configured for abracadabra"
}
idxttl.doLast {
  boolean prefix = project.hasProperty("prefix-all")

  File inv 
  File idxDir

  if ((idxinv != "") && (idxarchive != ""))   {
    try {
      inv = new File("${idxinv}")
      idxDir = new File("${idxarchive}")
    } catch (Exception e) {
      System.err.println "idxttl: unable to make index inventory and archive."
      throw e
    }
    CiteIndex idx = new CiteIndex(inv, idxDir)

    if (! buildDir.exists()) {
      buildDir.mkdir()
    }
    File ttlDir = new File(buildDir, "ttl")
    if (! ttlDir.exists()) {
      ttlDir.mkdir()
    }
    File outFile = new  File (ttlDir,"indices.ttl")
    idx.ttl(outFile, prefix)
  }
}


task ttl (dependsOn: [ctsttl, imgttl, ccttl, idxttl]) {
  description = "Concatenates separate TTL files into a single graph."
  doLast {
    String charEnc = "UTF-8"
    String prefix = "${prefixString}"

    File ctsttl = new File("${buildDir}/ttl/cts.ttl")
    File collectionsttl = new File("${buildDir}/ttl/collections.ttl")
    File idxttl = new File("${buildDir}/ttl/indices.ttl")
    File citeimgttl = new File("${buildDir}/ttl/citeimgs.ttl")

    def srcFiles =  [ctsttl, collectionsttl, idxttl, citeimgttl]

    File ttl = new File("${buildDir}/ttl/all.ttl")        
    ttl.append( prefix )

    srcFiles.each {  f ->
      if (f.exists()) {
	ttl.withWriterAppend(charEnc) {writer -> 
	  f.newReader(charEnc).eachLine {String line -> 
	    writer << "\n${line}"         
	  } 
	}
      } }

// too slow to tolerate :-(
/*
        System.err.println "Adding data from cts ttl ..."
        ctsttl.eachLine(charEnc) {
            ttl.append("${it}\n")
        }

        System.err.println "Adding data from collections ttl ..."
        collectionsttl.eachLine(charEnc) {
            ttl.append("${it}\n")
        }


        System.err.println "Adding data from index ttl ..."
        idxttl.eachLine(charEnc) {
            ttl.append("${it}\n")
        }



        System.err.println "Adding data from image ttl ..."
        citeimgttl.eachLine(charEnc) {
            ttl.append("${it}\n")
        }
*/

// Big project runs out of memory with this approach :-(
//+ ctsttl.getText(charEnc) + collectionsttl.getText(charEnc) + idxttl.getText(charEnc) + citeimgttl.getText(charEnc), charEnc)

        System.out.println "\nCompleted generating all TTL in ${buildDir}/ttl.\n"
    }
}



task showProj() {
  println "file://${projectDir}/${collectionInvUrl}"
}

uploadArchives {
    repositories.mavenDeployer {
        repository(url: nexusRepo) {
            authentication (userName: nexusUser, password: nexusPassword)
        }
    }
}

task zipTtl(type: Zip, dependsOn: [ttl]) {
  description = "Builds a zip file of all TTL output"
  from(file("${buildDir}/ttl"))
  include("**/*.ttl")
}

artifacts {
  rdf zipTtl
  lib jar
}


task cleanTest () {
  description = "Deletes contents of test output directory."
  doLast {
    File out1 = new File("testdata/testoutput")
    if (out1.exists()) { 
      out1.listFiles().each { f ->
	System.err.println "Delete " + f
	f.delete()
      }
      out1.delete() 
    }
    out1.mkdir()
  }
}


test.dependsOn cleanTest

uploadLib {
  repositories.mavenDeployer {
    repository(url: nexusRepo) {                   
      authentication (userName: nexusUser, password: nexusPassword)
    }
  }
  doLast {
    System.err.println "Code library uploaded."
  }
}



// for specs with concordion:
sourceSets {
    main {
        java {
            srcDir 'src'
        }
        resources {
            srcDir 'src'
        }
    }
    test {
        java {
	  srcDir "specs/java"
        }
        resources {
	  srcDir "${buildDir}/specs"
        }
    }
}

task cpResources(type: Copy) {
  from "specs/resources"
  into "${buildDir}/specs"
}

task setUpResources(dependsOn: cpResources) {
}
setUpResources.doLast {
  println "READING FILE TREE FROM " + mdSrc
  FileTree tree = fileTree(mdSrc) {
    include "**/*.md"
  }
  tree.visit { f ->
    if (f.relativePath.isFile()) {
      File inFile = new File("${mdSrc}/${f.relativePath}")
      println "Need to work on " + inFile
      def segs = f.relativePath.getSegments()
      String treePath = "${buildDir}/specs"
      Integer limit =  segs.size() - 1
      segs.eachWithIndex { s, i ->
	if (i < limit) {
	  treePath = "${treePath}/${s}"
	  File nxtDir = new File(treePath)
	  if (! nxtDir.exists()) {
	    nxtDir.mkdir()
	  }
	}
      }
      File outDir = new File(treePath)
      String htmlFileName = f.relativePath.getLastName().replaceFirst(/.md$/,".html")
      File htmlFile = new File(outDir, htmlFileName)
      println "Created ${htmlFile}"

      String body = Processor.process(inFile.getText("UTF-8"),Configuration.DEFAULT)
      htmlFile.setText("${htmlPreface}${body}${htmlEnd}", "UTF-8")
    }
  }
}


test.dependsOn setUpResources
test {
    systemProperties 'concordion.output.dir': file("${buildDir}/concordion-results")

}


task addVersion () {
}
addVersion.doLast {
  tokenMap["version"] = version
  tokenMap["deps"] = """
    <tr><td>cite</td><td>${citeVersion}</td></tr>
    <tr><td>nysi</td><td>${nysiVersion}</td></tr>
    <tr><td>abracadabra</td><td>${abracadabraVersion}</td></tr>
    <tr><td>prestochango</td><td>${prestochangoVersion}</td></tr>
    <tr><td>hocuspocus</td><td>${hocuspocusVersion}</td></tr>
    <tr><td>hmt-utils</td><td>${hmtutilsVersion}</td></tr>
    <tr><td>greekutils</td><td>${greekutilsVersion}</td></tr>""".toString() 
}

task conc(type: Copy, dependsOn: [test, addVersion]) {
  from "${buildDir}/concordion-results"
  into "${buildDir}/concordion-formatted"
  filter(ReplaceTokens, tokens: tokenMap)
}
